"use strict";

// tests for registrationPut
// Generated by serverless-mocha-plugin

import mochaPlugin from "serverless-mocha-plugin";
import {
  mockClient
} from "aws-sdk-client-mock";
import {
  DynamoDBDocumentClient, GetCommand, UpdateCommand
} from "@aws-sdk/lib-dynamodb";
import {
  SNSClient, PublishCommand
} from "@aws-sdk/client-sns";
import {
  SESClient, SendEmailCommand
} from "@aws-sdk/client-ses";
import {
  EVENTS_TABLE, USERS_TABLE, USER_REGISTRATIONS_TABLE
} from "../../../constants/tables";
import SESEmailService from "../EmailService/SESEmailService";

const expect = mochaPlugin.chai.expect;
let wrapped = mochaPlugin.getWrapper("registrationPut", "/handler.js", "put");

const email = "victorv@ubcbiztech.com";
const email2 = "victorv+2@ubcbiztech.com";

const userResponse = {
  studentId: 12200034,
  fname: "user",
  lname: "man",
  faculty: "Science",
  email: email
};

const eventResponse = {
  "id": "event",
  "year": 2020,
  "capac": 2,
  "createdAt": 1581227718674,
  "description": "I am a description",
  "elocation": "UBC",
  "ename": "Existing Event",
  "startDate": "2020-02-09T05:55:11.131Z",
  "endDate": "2020-02-09T05:55:11.131Z",
  "imageUrl": "https://i.picsum.photos/id/236/700/400.jpg",
  "updatedAt": 1581227718674
};

const registrationsResponse = [
  {
    email: email,
    eventID: "event",
    year: 2020,
    updatedAt: 1600669844493,
    registrationStatus: "registered"
  },
  {
    email: email2,
    eventID: "event",
    year: 2020,
    updatedAt: 1600669844493,
    registrationStatus: "registered"
  }
];

// Simple mock for email service
let emailCalls = [];
const mockEmailService = {
  sendDynamicQR: async (event, user, status, emailType) => {
    emailCalls.push({
      type: "qr",
      event,
      user,
      status,
      emailType
    });
    return {
    };
  },
  sendCalendarInvite: async (event, user) => {
    emailCalls.push({
      type: "calendar",
      event,
      user
    });
    return {
    };
  }
};

// Override the SESEmailService constructor
SESEmailService.prototype.constructor = () => mockEmailService;

// Add this helper function at the top of the file
const isString = (value) => typeof value === "string";

describe("registrationPut", () => {
  const ddbMock = mockClient(DynamoDBDocumentClient);
  const snsMock = mockClient(SNSClient);
  const sesMock = mockClient(SESClient);

  beforeEach(() => {
    ddbMock.reset();
    snsMock.reset();
    sesMock.reset();
    emailCalls = []; // Reset email calls

    // Mock SES SendEmail
    sesMock.on(SendEmailCommand).resolves({
      MessageId: "mock-email-id",
      $metadata: {
        httpStatusCode: 200
      }
    });

    // Mock SNS Publish
    snsMock.on(PublishCommand).resolves({
      MessageId: "mock-sns-id",
      $metadata: {
        httpStatusCode: 200
      }
    });

    // Mock Get Command
    ddbMock.on(GetCommand).callsFake(params => {
      if (params.TableName.includes(EVENTS_TABLE)) {
        if (params.Key.id === "event" && params.Key.year === 2020) {
          return {
            Item: {
              ...eventResponse,
              registrations: registrationsResponse
            }
          };
        }
        return {
          Item: null
        };
      } else if (params.TableName.includes(USER_REGISTRATIONS_TABLE)) {
        if (params.Key.id === email && params.Key["eventID;year"] === "event;2020") {
          return {
            Item: registrationsResponse[0]
          };
        }
        return {
          Item: null
        };
      } else if (params.TableName.includes(USERS_TABLE)) {
        if (params.Key.id === email) {
          return {
            Item: userResponse
          };
        }
        return {
          Item: null
        };
      }
      return {
        Item: null
      };
    });

    // Mock Update Command
    ddbMock.on(UpdateCommand).callsFake(params => {
      if (params.TableName.includes(USER_REGISTRATIONS_TABLE)) {
        if (!params.Key.id) {
          throw {
            name: "ValidationException"
          };
        } else if (params.Key.id === email2) {
          throw {
            name: "ConditionalCheckFailedException"
          };
        }
        return {
          Attributes: {
            ...params.ExpressionAttributeValues,
            id: params.Key.id
          }
        };
      }
    });
  });

  afterEach(() => {
    ddbMock.restore();
    snsMock.restore();
    sesMock.restore();
  });

  // Email service tests
  it("should send emails when updating to registered status", async () => {
    const response = await wrapped.run({
      pathParameters: {
        email
      },
      body: JSON.stringify({
        eventID: "event",
        year: 2020,
        registrationStatus: "registered"
      })
    });

    expect(response.statusCode).to.equal(200);
    expect(sesMock.calls()).to.have.lengthOf(2); // QR and Calendar emails
  });

  it("should send only QR email for waitlist status", async () => {
    const response = await wrapped.run({
      pathParameters: {
        email
      },
      body: JSON.stringify({
        eventID: "event",
        year: 2020,
        registrationStatus: "waitlist"
      })
    });

    expect(response.statusCode).to.equal(200);
    expect(sesMock.calls()).to.have.lengthOf(1); // Only QR email
  });

  it("should return 400 when email parameter is not given ", async () => {
    const response = await wrapped.run({
      body: JSON.stringify({
        eventID: "event",
        year: 2020,
        registrationStatus: "registered"
      })
    });
    expect(response.statusCode).to.be.equal(400);
  });

  it("should return 406 when no eventID is provided", async () => {
    const response = await wrapped.run({
      body: JSON.stringify({
        registrationStatus: "registered",
        year: 2020,
      }),
      pathParameters: {
        email: email
      }
    });
    expect(response.statusCode).to.be.equal(406);
  });

  it("should return 406 when year is not provided", async () => {
    const response = await wrapped.run({
      body: JSON.stringify({
        eventID: "event",
        registrationStatus: "registered"
      }),
      pathParameters: {
        email: email
      }
    });
    expect(response.statusCode).to.be.equal(406);
  });

  it("should return 406 when no registrationStatus is provided", async () => {
    const response = await wrapped.run({
      pathParameters: {
        email
      },
      body: JSON.stringify({
        eventID: "event",
        year: 2020
      })
    });
    expect(response.statusCode).to.equal(406);
  });

  it("should return 404 when unknown eventID is provided", async () => {
    const response = await wrapped.run({
      body: JSON.stringify({
        eventID: "unknownevent",
        year: 2020,
        registrationStatus: "registered"
      }),
      pathParameters: {
        email: email
      }
    });
    expect(response.statusCode).to.be.equal(404);
  });

  it("should return 404 when unknown email is provided", async () => {
    const response = await wrapped.run({
      body: JSON.stringify({
        eventID: "event",
        year: 2020,
        registrationStatus: "registered"
      }),
      pathParameters: {
        email: "victorv@ubcbiztech.com"
      }
    });
    expect(response.statusCode).to.be.equal(404);
  });

  it("should return 200 for successful update of registration as waitlist", async () => {
    const response = await wrapped.run({
      pathParameters: {
        email
      },
      body: JSON.stringify({
        eventID: "event",
        year: 2020,
        registrationStatus: "waitlist"
      })
    });
    expect(response.statusCode).to.equal(200);
  });

  it("should return 200 for successful update of registration with maximum capac", async () => {
    const response = await wrapped.run({
      body: JSON.stringify({
        eventID: "event",
        year: 2020,
        registrationStatus: "registered"
      }),
      pathParameters: {
        email: email
      }
    });

    const body = JSON.parse(response.body);
    expect(response.statusCode).to.equal(200);
    expect(body.registrationStatus).to.equal("waitlist");
  });

  it("should return 409 for trying to update registration entry that doesn't exist", async () => {
    const response = await wrapped.run({
      pathParameters: {
        email: email2
      },
      body: JSON.stringify({
        eventID: "event",
        year: 2020,
        registrationStatus: "registered"
      })
    });
    expect(response.statusCode).to.equal(409);
  });

  // Add test to verify SNS notification
  it("should send SNS notification on successful update", async () => {
    const response = await wrapped.run({
      pathParameters: {
        email
      },
      body: JSON.stringify({
        eventID: "event",
        year: 2020,
        registrationStatus: "registered"
      })
    });

    expect(response.statusCode).to.equal(200);
    expect(snsMock.calls()).to.have.lengthOf(1);

    const publishCall = snsMock.calls()[0];
    expect(publishCall.args[0].input).to.have.property("Message");
    expect(publishCall.args[0].input).to.have.property("TopicArn");
  });
});
