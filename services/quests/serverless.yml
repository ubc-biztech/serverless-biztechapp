service: biztech-quests

frameworkVersion: "3"

plugins:
  - serverless-dynamodb
  - serverless-offline
  - serverless-bundle
  - serverless-domain-manager
  - serverless-prune-plugin
  - serverless-mocha-plugin

provider:
  name: aws
  stage: ${file(../../serverless.common.yml):provider.stage}
  runtime: ${file(../../serverless.common.yml):provider.runtime}
  region: ${file(../../serverless.common.yml):provider.region}
  cfLogs: true
  environment:
    ENVIRONMENT: ${file(../../config.${self:provider.stage}.json):ENVIRONMENT}
    NODE_ENV: ${env:NODE_ENV}
  timeout: 15 # in seconds
  apiGateway:
    restApiId: !ImportValue ${self:provider.stage}-ExtApiGatewayRestApiId
    restApiRootResourceId: !ImportValue ${self:provider.stage}-ExtApiGatewayRestApiRootResourceId

  # This matches your code pattern: TableName = table + (process.env.ENVIRONMENT || "")
  environment:
    ENVIRONMENT: -${self:provider.stage}
    QUESTS_TABLE: ${self:custom.questsTableBaseName}

  iam:
    role:
      statements:
        - Effect: Allow
          Action:
            - dynamodb:Scan
            - dynamodb:Query
            - dynamodb:GetItem
            - dynamodb:PutItem
            - dynamodb:UpdateItem
            - dynamodb:DeleteItem
            - dynamodb:Query
          Resource:
            - arn:aws:dynamodb:${aws:region}:${aws:accountId}:table/${self:custom.questsTableBaseName}${self:provider.environment.ENVIRONMENT}


custom:
  # IMPORTANT:
  # Your code appends ENVIRONMENT (e.g., "-dev") at runtime.
  # So the *physical* table should be named like: biztech-quests-dev
  questsTableBaseName: biztech-quests

functions:
  # Optional but typical endpoints (rename handlers to match your repo)
  getQuests:
    handler: src/handlers/quests/getAllQuest.getAllQuest
    events:
      - http:
          path: quests
          method: get
          cors: true

  updateQuest:
    handler: src/handlers/quests/updateQuest.updateQuest
    events:
      - http:
          path: quests
          method: post
          cors: true

resources:
  Resources:
    BiztechQuests:
      Type: AWS::DynamoDB::Table
      Properties:
        TableName: biztechQuests${self:provider.environment.ENVIRONMENT}
        BillingMode: PAY_PER_REQUEST
        AttributeDefinitions:
          - AttributeName: id # user id is their email 
            AttributeType: S
          - AttributeName: eventID;year
            AttributeType: S

        KeySchema:
          - AttributeName: id # user id is their email 
            KeyType: HASH
          - AttributeName: eventID;year
            KeyType: RANGE

        # see if necessary 
        GlobalSecondaryIndexes:
          - IndexName: event-query
            KeySchema:
              - AttributeName: eventID;year
                KeyType: HASH
              - AttributeName: id
                KeyType: RANGE
            Projection:
              ProjectionType: ALL


        SSESpecification:
          SSEEnabled: true

  Outputs:
    QuestsTableName:
      Value: ${self:custom.questsTableBaseName}${self:provider.environment.ENVIRONMENT}

# How quest progress is stored in DynamoDB


# # get quest plus progress via quests[questId] for this user+event
#   for each quest definition q:

# questsMap[q.id] gives you the saved progress

# otherwise you call initProgress(q)

# What “the value” should contain (by type)
# COUNTER quest value

# Stores only count + target + status

# {
#   status: "NOT_STARTED" | "IN_PROGRESS" | "COMPLETED",
#   count: number,
#   target: number,
#   updatedAt: number
# }

# UNIQUE_SET quest value

# Stores the unique items, plus count derived from length

# {
#   status: "NOT_STARTED" | "IN_PROGRESS" | "COMPLETED",
#   items: string[],
#   count: number,
#   target: number | undefined,
#   updatedAt: number
# }

# Important detail: the quest id should NOT live inside the value


# because the key already tells you which quest it is.

# When PATCH happens: what gets updated

# Your update handler receives an event like:

# { eventType: "NEW_CONNECTION", eventPayload: {} }


# Then you update only the quests whose params.eventType matches:

# for all quests where quest.params.eventType === "NEW_CONNECTION"

# update their stored value at quests[quest.id]

# So yes: key = quest id, value = that quest’s evolving progress object.

# …but if multiple quests share the same event type (like 5/10/20 connections), you’ll do that update for each matching quest (or rebuild the whole quests map and SET quests = :nextQuests).