"use strict";

// tests for userFavEvent
// Generated by serverless-mocha-plugin

import mochaPlugin from "serverless-mocha-plugin";
const expect = mochaPlugin.chai.expect;
import AWSMock from "aws-sdk-mock";
let wrapped = mochaPlugin.getWrapper("userFavEvent", "/handler.js", "favouriteEvent");
import {
  USERS_TABLE, EVENTS_TABLE
} from "../../../constants/tables";

const testEntry = {
  eventID: "some event id",
  year: 2020,
  isFavourite: true
};

const email = "test@gmail.com";
const userObject = {
  studentId: "6456456464",
  fname: "insanetest",
  lname: "dude",
  faculty: "Science",
  email: email
};

describe("userFavEvent", () => {
  before(() => {
    AWSMock.mock("DynamoDB.DocumentClient", "get", (params, callback) => {
      if(params.TableName.includes(USERS_TABLE) && params.Key.id === email) {
        callback(null, {
          Item: userObject
        });
      }
      else if(params.TableName.includes(EVENTS_TABLE) && params.Key.id === "some event id" && params.Key.year === 2020) {
        callback(null, {
          Item: {
            id: "some event id",
            year: 2020,
            capac: 100
          }
        });
      }
      else callback(null, {
        Item: null
      });
    });

    AWSMock.mock("DynamoDB.DocumentClient", "update", function (params, callback) {
      callback(null, {
        Item: "not null user"
      });
    });
  });

  after(() => {
    AWSMock.restore("DynamoDB.DocumentClient");
  });

  it("returns 406 when eventID and year not provided", async () => {
    const response = await wrapped.run({
      body: JSON.stringify({
        isFavourite: true
      }),
      pathParameters: {
        email: email
      }
    });
    expect(response.statusCode).to.equal(406);
  });

  it("returns 406 when year is not provided ", async () => {
    const response = await wrapped.run({
      body: JSON.stringify({
        eventID: "some event id",
        isFavourite: true
      }),
      pathParameters: {
        email: email
      }
    });
    expect(response.statusCode).to.equal(406);
  });

  it("returns 406 when year is not a number ", async () => {
    const response = await wrapped.run({
      body: JSON.stringify({
        eventID: "some event id",
        year: "not a number",
        isFavourite: true
      }),
      pathParameters: {
        email: email
      }
    });
    expect(response.statusCode).to.equal(406);
  });

  it("returns 406 when isFavourite is not provided", async () => {
    const response = await wrapped.run({
      body: JSON.stringify({
        eventID: "some event id",
        year: 2020
      }),
      pathParameters: {
        email: email
      }
    });
    expect(response.statusCode).to.equal(406);
  });

  it ("returns 406 when isFavourite is not a boolean", async () => {
    const response = await wrapped.run({
      body: JSON.stringify({
        eventID: "some event id",
        year: 2020,
        isFavourite: "not a boolean"
      }),
      pathParameters: {
        email: email
      }
    });
    expect(response.statusCode).to.equal(406);
  });

  it ("returns 404 when user does not exist", async () => {
    const response = await wrapped.run({
      body: JSON.stringify({
        eventID: "some event id",
        year: 2020,
        isFavourite: true
      }),
      pathParameters: {
        email: "asdf@gmail.com"
      }
    });
    expect(response.statusCode).to.equal(404);
  });

  it ("returns 404 when event does not exist", async () => {
    const response = await wrapped.run({
      body: JSON.stringify({
        eventID: "some event that does not exist",
        year: 2020,
        isFavourite: true
      }),
      pathParameters: {
        email: email
      }
    });
    expect(response.statusCode).to.equal(404);
  });

  it("returns 200 when given valid data", async () => {
    const response = await wrapped.run({
      body: JSON.stringify(testEntry),
      pathParameters: {
        email: email
      }
    });
    expect(response.statusCode).to.equal(200);
  });

  it("returns 200 when given valid data (false)", async () => {
    const response = await wrapped.run({
      body: JSON.stringify({
        ...testEntry,
        isFavourite: false
      }),
      pathParameters: {
        email: email
      }
    });
    expect(response.statusCode).to.equal(200);
  });
});
